name = "Argo Rollout [Canary]"
description = "Performs Argo Rollout"

parameter "Target Tags" {
    display_settings = {
        Octopus.ControlType = "TargetTags"
    }
    help_text = "This will be sourced from Project's Target Tags"
    label = ""
}

parameter "Worker Pool" {
    display_settings = {
        Octopus.ControlType = "WorkerPool"
    }
    help_text = "Sourced from Worker Pool of Project"
    label = ""
}

parameter "RolloutName" {
    display_settings = {
        Octopus.ControlType = "SingleLineText"
    }
    help_text = ""
    label = ""
}

parameter "RolloutNameSpace" {
    display_settings = {
        Octopus.ControlType = "SingleLineText"
    }
    help_text = ""
    label = ""
}

parameter "ApplicationName" {
    display_settings = {
        Octopus.ControlType = "SingleLineText"
    }
    help_text = ""
    label = ""
}

parameter "IngressName" {
    display_settings = {
        Octopus.ControlType = "SingleLineText"
    }
    help_text = ""
    label = ""
}

parameter "IngressActionAnnotation" {
    display_settings = {
        Octopus.ControlType = "SingleLineText"
    }
    help_text = ""
    label = ""
}

step "increase-traffic-to-20" {
    name = "Increase Traffic to 20%"

    action {
        action_type = "Octopus.Manual"
        properties = {
            Octopus.Action.Manual.BlockConcurrentDeployments = "False"
            Octopus.Action.Manual.Instructions = "Increases Traffic to 20%"
            Octopus.Action.Manual.ResponsibleTeamIds = "global/octopus-managers"
        }
    }
}

step "argo-rollouts-promote-20" {
    name = "Argo - Rollouts Promote (20%)"
    properties = {
        Octopus.Action.TargetRoles = "#{Target Tags}"
    }

    action {
        action_type = "Octopus.KubernetesRunScript"
        properties = {
            Argo.Rollout.FullPromotion = "False"
            Argo.Rollout.Name = "#{RolloutName}"
            Argo.Rollout.Namespace = "#{RolloutNameSpace}"
            Octopus.Action.Script.ScriptBody = <<-EOT
                # Installs the Argo Rollouts plugin
                function Install-Plugin
                {
                # Define parameters
                	param ($PluginUri,
                           $PluginFilename
                    )
                    
                    # Check for plugin folder
                    if ((Test-Path -Path "$PWD/plugins") -eq $false)
                    {
                		# Create new plugins folder
                        New-Item -Path "$PWD/plugins" -ItemType "Directory"
                        
                        # Add to path
                        $env:PATH = "$($PWD)/plugins$([IO.Path]::PathSeparator)" + $env:PATH
                    }
                
                	# Download plugin
                	Invoke-WebRequest -Uri "$PluginUri" -OutFile "$PWD/plugins/$PluginFilename"
                
                	# Make file executable
                    if ($IsLinux)
                    {
                		# Make it executable
                    	chmod +x ./plugins/$PluginFilename
                    }
                    
                    if ($IsWindows)
                    {
                    	# Update filename to include .exe extension
                        Rename-Item -Path "$PWD/plugins/$PluginFilename" -NewName "$PWD/plugins/$($PluginFilename).exe"
                    }
                }
                
                # When listing plugins, kubectl looks in all paths defined in $env:PATH and will fail if the path does not exist
                function Verify-Path-Variable
                {
                	# Get current path and split into array
                    $paths = $env:PATH.Split([IO.Path]::PathSeparator)
                    $verifiedPaths = @()
                    
                    # Loop through paths
                    foreach ($path in $paths)
                    {
                    	# Check for existence
                        if ((Test-Path -Path $path) -eq $true)
                        {
                        	# Add to verified
                            $verifiedPaths += $path
                        }
                    }
                    
                    # Return verified paths
                    return ($verifiedPaths -join [IO.Path]::PathSeparator)
                }
                
                function Get-Plugin-Installed
                {
                	# Define parameters
                    param (
                    	$PluginName,
                        $InstalledPlugins
                        )
                        
                   	$isInstalled = $false
                   
                	foreach ($plugin in $installedPlugins)
                   	{
                		if ($plugin -like "$($PluginName)*")
                        {
                        	$isInstalled = $true
                          	break
                        }
                	}
                    
                    return $isInstalled
                }
                
                # Check to see if $IsWindows is available
                if ($null -eq $IsWindows) {
                    Write-Host "Determining Operating System..."
                    $IsWindows = ([System.Environment]::OSVersion.Platform -eq "Win32NT")
                    $IsLinux = ([System.Environment]::OSVersion.Platform -eq "Unix")
                }
                
                # Fix ANSI Color on PWSH Core issues when displaying objects
                if ($PSEdition -eq "Core") {
                    $PSStyle.OutputRendering = "PlainText"
                }
                
                # Check to see if it's running on Windows
                if ($IsWindows) {
                    # Disable the progress bar so downloading files via Invoke-WebRequest are faster
                    $ProgressPreference = 'SilentlyContinue'
                }
                
                # Set TLS
                [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [System.Net.SecurityProtocolType]::Tls12
                
                # Verify all PATH variables are avaialable
                $env:PATH = Verify-Path-Variable
                if ($IsLinux)
                {
                	$pluginUri = "https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64"
                }
                
                if ($IsWindows)
                {
                	$pluginUri = "https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-windows-amd64"
                }
                
                try 
                {
                    # Check to see if plugins are installed
                    $pluginList = (kubectl plugin list 2>&1)
                
                    # This is the path that Linux will take
                    if ($lastExitCode -ne 0 -and $pluginList.Exception.Message -eq "error: unable to find any kubectl plugins in your PATH") 
                    {
                        Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"
                    }
                    else
                    {
                        # Parse list
                    	$pluginList = $pluginList.Split("`n", [System.StringSplitOptions]::RemoveEmptyEntries)
                        
                        if ((Get-Plugin-Installed -PluginName "kubectl-argo-rollouts" -InstalledPlugins $pluginList) -eq $false)
                        {
                        	Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"
                        }
                        else
                        {
                        	Write-Host "Argo Rollout kubectl plugin found ..."
                        }
                    }    
                }
                catch
                {
                	# On Windows, the executable will cause an error if no plugins found so this the path Windows will take
                    if ($_.Exception.Message -eq "error: unable to find any kubectl plugins in your PATH")
                    {
                		Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"    
                    }
                    else
                    {
                    	# Something else happened, we need to surface the error
                        throw
                    }
                }
                
                # Get parameters
                $rolloutsName = $OctopusParameters['Argo.Rollout.Name']
                $rolloutsNamespace = $OctopusParameters['Argo.Rollout.Namespace']
                $rolloutsFullPromotion = [System.Convert]::ToBoolean($OctopusParameters['Argo.Rollout.FullPromotion'])
                
                # Create arguments array
                $kubectlArguments = @("argo", "rollouts", "promote", $rolloutsName, "--namespace", $rolloutsNamespace)
                
                # Check for additional argument
                if ($rolloutsFullPromotion)
                {
                	$kubectlArguments += "--full"
                }
                
                # Promote rollout
                kubectl $kubectlArguments
                EOT
            Octopus.Action.Script.ScriptSource = "Inline"
            Octopus.Action.Script.Syntax = "PowerShell"
        }
        worker_pool_variable = "#{Worker Pool}"

        community_action_template_snapshot {
            id = "CommunityActionTemplates-30"
            version = 1

            parameter "Argo.Rollout.Name" {
                display_settings = {
                    Octopus.ControlType = "SingleLineText"
                }
                help_text = "Name of the Argo Rollout to promote."
                label = "Rollout Name"
                default_value = ""
            }

            parameter "Argo.Rollout.Namespace" {
                display_settings = {
                    Octopus.ControlType = "SingleLineText"
                }
                help_text = "The namespace to execute the promotion of the rollout against."
                label = "Namespace"
                default_value = "default"
            }

            parameter "Argo.Rollout.FullPromotion" {
                display_settings = {
                    Octopus.ControlType = "Checkbox"
                }
                help_text = "Fully promote a rollout to desired version, skipping analysis, pauses, and steps"
                label = "Full Promotion"
                default_value = "False"
            }
        }
    }
}

step "wait-for-traffic-shift-and-testing-to-complete" {
    name = "Wait For - Traffic Shift and Testing to Complete"

    action {
        action_type = "Octopus.Script"
        properties = {
            Octopus.Action.RunOnServer = "true"
            Octopus.Action.Script.ScriptBody = <<-EOT
                #!/bin/bash
                
                set -e
                
                # Get parameters from Octopus Deploy Process Template
                ROLLOUT_NAME="#{RolloutName}"
                EXPECTED_CANARY_WEIGHT="20"
                NAMESPACE="#{RolloutNameSpace}"
                
                # Optional parameters with defaults
                MAX_WAIT_TIME="600"
                CHECK_INTERVAL="5"
                
                # Colors for output
                RED='\033[0;31m'
                GREEN='\033[0;32m'
                YELLOW='\033[1;33m'
                NC='\033[0m'
                
                # All log functions output to stderr to not interfere with function return values
                log_info() {
                    echo -e "${GREEN}[INFO]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
                }
                
                log_warn() {
                    echo -e "${YELLOW}[WARN]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
                }
                
                log_error() {
                    echo -e "${RED}[ERROR]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
                }
                
                log_debug() {
                    echo -e "${YELLOW}[DEBUG]${NC} $(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
                }
                
                validate_params() {
                    local missing_params=()
                    
                    if [[ -z "$ROLLOUT_NAME" ]]; then missing_params+=("Result Rollout Name"); fi
                    if [[ -z "$NAMESPACE" ]]; then missing_params+=("Environment Rollout NameSpace"); fi
                    
                    if [[ ${#missing_params[@]} -gt 0 ]]; then
                        log_error "Missing required Octopus Deploy Process Template parameters:"
                        for param in "${missing_params[@]}"; do
                            log_error "  - $param"
                        done
                        exit 1
                    fi
                }
                
                # Get current canary weight from Rollout using kubectl
                get_current_canary_weight() {
                    local rollout_name=$1
                    local namespace=$2
                    
                    log_debug "Querying Rollout: $rollout_name in namespace: $namespace"
                    
                    # Get the Rollout resource
                    local rollout_json
                    rollout_json=$(kubectl get rollout "$rollout_name" -n "$namespace" -o json 2>&1)
                    local kubectl_status=$?
                    
                    if [[ $kubectl_status -ne 0 ]]; then
                        log_error "kubectl get rollout failed with exit code: $kubectl_status"
                        log_error "Output: ${rollout_json:0:500}"
                        return 1
                    fi
                    
                    if [[ -z "$rollout_json" ]]; then
                        log_error "kubectl returned empty output"
                        return 1
                    fi
                    
                    log_debug "Retrieved Rollout JSON (${#rollout_json} bytes)"
                    
                    # Extract canary weight from status
                    local canary_weight
                    canary_weight=$(echo "$rollout_json" | jq -r '.status.canary.weights.canary.weight // empty' 2>&1)
                    local jq_status=$?
                    
                    if [[ $jq_status -ne 0 ]]; then
                        log_error "Failed to parse Rollout JSON (jq exit code: $jq_status)"
                        log_error "jq output: $canary_weight"
                        return 1
                    fi
                    
                    if [[ -z "$canary_weight" ]]; then
                        log_error "Could not extract canary weight from Rollout status"
                        log_debug "Canary weights object:"
                        echo "$rollout_json" | jq '.status.canary.weights' >&2
                        return 1
                    fi
                    
                    log_debug "Successfully extracted canary weight: $canary_weight"
                    echo "$canary_weight"
                    return 0
                }
                
                wait_for_traffic_update() {
                    local expected_weight=$1
                    local start_time=$(date +%s)
                    
                    log_info "Waiting for canary weight to reach: ${expected_weight}%"
                    
                    while true; do
                        local current_weight
                        current_weight=$(get_current_canary_weight "$ROLLOUT_NAME" "$NAMESPACE")
                        local weight_status=$?
                        
                        if [[ $weight_status -ne 0 ]]; then
                            log_error "Failed to retrieve current canary weight (exit code: $weight_status)"
                            
                            local elapsed=$(($(date +%s) - start_time))
                            if [[ $elapsed -gt $MAX_WAIT_TIME ]]; then
                                log_error "Timeout waiting for canary weight update"
                                return 1
                            fi
                            
                            log_info "Retrying in ${CHECK_INTERVAL}s..."
                            sleep $CHECK_INTERVAL
                            continue
                        fi
                        
                        if [[ -z "$current_weight" ]]; then
                            log_error "Retrieved empty weight value"
                            
                            local elapsed=$(($(date +%s) - start_time))
                            if [[ $elapsed -gt $MAX_WAIT_TIME ]]; then
                                log_error "Timeout waiting for canary weight update"
                                return 1
                            fi
                            
                            log_info "Retrying in ${CHECK_INTERVAL}s..."
                            sleep $CHECK_INTERVAL
                            continue
                        fi
                        
                        if [[ "$current_weight" == "$expected_weight" ]]; then
                            log_info "✓ Canary weight successfully updated to ${expected_weight}%"
                            return 0
                        fi
                        
                        local elapsed=$(($(date +%s) - start_time))
                        if [[ $elapsed -gt $MAX_WAIT_TIME ]]; then
                            log_error "Timeout waiting for canary weight update. Current: ${current_weight}%, Expected: ${expected_weight}%"
                            return 1
                        fi
                        
                        log_info "Current weight: ${current_weight}%, Expected: ${expected_weight}% (waiting...)"
                        sleep $CHECK_INTERVAL
                    done
                }
                
                # Check rollout health
                check_rollout_health() {
                    local rollout_name=$1
                    local namespace=$2
                    
                    log_info "Checking rollout health..."
                    
                    local rollout_json
                    rollout_json=$(kubectl get rollout "$rollout_name" -n "$namespace" -o json 2>&1)
                    local kubectl_status=$?
                    
                    if [[ $kubectl_status -ne 0 ]]; then
                        log_error "Failed to get rollout status"
                        return 1
                    fi
                    
                    local phase=$(echo "$rollout_json" | jq -r '.status.phase // "Unknown"')
                    local health_status=$(echo "$rollout_json" | jq -r '.status.health.status // "Unknown"')
                    local message=$(echo "$rollout_json" | jq -r '.status.message // "N/A"')
                    
                    log_info "Rollout Phase: $phase"
                    log_info "Health Status: $health_status"
                    log_info "Message: $message"
                    
                    # Check for unhealthy conditions
                    if [[ "$phase" == "Degraded" ]] || [[ "$health_status" == "Degraded" ]]; then
                        log_error "Rollout is in degraded state"
                        echo "$rollout_json" | jq '.status' >&2
                        return 1
                    fi
                    
                    # Check for abort condition
                    local abort_condition=$(echo "$rollout_json" | jq -r '.status.abort // false')
                    if [[ "$abort_condition" == "true" ]]; then
                        log_error "Rollout has been aborted"
                        return 1
                    fi
                    
                    return 0
                }
                
                # Check for active AnalysisRuns
                check_analysis_runs() {
                    local rollout_name=$1
                    local namespace=$2
                    
                    log_info "Checking for active AnalysisRuns..."
                    
                    local rollout_json
                    rollout_json=$(kubectl get rollout "$rollout_name" -n "$namespace" -o json 2>&1)
                    
                    if [[ $? -ne 0 ]]; then
                        log_warn "Could not retrieve rollout status"
                        echo ""
                        return 0
                    fi
                    
                    # Get current step index
                    local current_step=$(echo "$rollout_json" | jq -r '.status.currentStepIndex // 0')
                    log_info "Current rollout step: $current_step"
                    
                    # Check for current step analysis run
                    local current_analysis=$(echo "$rollout_json" | jq -r '.status.canary.currentStepAnalysisRun // empty')
                    
                    if [[ -n "$current_analysis" ]]; then
                        log_info "Active AnalysisRun from rollout status: $current_analysis"
                        echo "$current_analysis"
                        return 0
                    fi
                    
                    # If not found in rollout status, search for AnalysisRuns by label
                    log_info "No AnalysisRun in rollout status, searching by labels..."
                    
                    # Get the current revision and pod hash to find the correct AnalysisRun
                    local current_revision=$(echo "$rollout_json" | jq -r '.metadata.annotations."rollout.argoproj.io/revision" // empty')
                    local current_hash=$(echo "$rollout_json" | jq -r '.status.currentPodHash // empty')
                    
                    log_debug "Current revision: $current_revision"
                    log_debug "Current pod hash: $current_hash"
                    
                    # Try to find AnalysisRuns matching current revision and hash
                    local ar_list=$(kubectl get analysisruns -n "$namespace" -o json 2>/dev/null)
                    
                    if [[ -n "$ar_list" ]]; then
                        # First try: Find Step AnalysisRun for current revision and hash
                        local recent_ar=$(echo "$ar_list" | jq -r --arg rollout "$rollout_name" --arg rev "$current_revision" --arg hash "$current_hash" '
                            .items[] | 
                            select(
                                .metadata.ownerReferences[]?.name == $rollout and
                                .metadata.annotations."rollout.argoproj.io/revision" == $rev and
                                .metadata.labels."rollouts-pod-template-hash" == $hash and
                                .metadata.labels."rollout-type" == "Step"
                            ) | 
                            .metadata.name' | tail -1)
                        
                        if [[ -n "$recent_ar" ]]; then
                            log_info "Found Step AnalysisRun for current revision: $recent_ar"
                            echo "$recent_ar"
                            return 0
                        fi
                        
                        # Second try: Find Background AnalysisRun for current hash
                        recent_ar=$(echo "$ar_list" | jq -r --arg rollout "$rollout_name" --arg hash "$current_hash" '
                            .items[] | 
                            select(
                                .metadata.ownerReferences[]?.name == $rollout and
                                .metadata.labels."rollouts-pod-template-hash" == $hash and
                                .metadata.labels."rollout-type" == "Background"
                            ) | 
                            .metadata.name' | tail -1)
                        
                        if [[ -n "$recent_ar" ]]; then
                            log_info "Found Background AnalysisRun for current hash: $recent_ar"
                            echo "$recent_ar"
                            return 0
                        fi
                        
                        # Third try: Most recent AnalysisRun for this rollout
                        recent_ar=$(echo "$ar_list" | jq -r --arg rollout "$rollout_name" '
                            .items[] | 
                            select(.metadata.ownerReferences[]?.name == $rollout) |
                            {name: .metadata.name, created: .metadata.creationTimestamp}' | 
                            jq -s 'sort_by(.created) | .[-1].name // empty')
                        
                        if [[ -n "$recent_ar" ]]; then
                            log_info "Found most recent AnalysisRun for rollout: $recent_ar"
                            echo "$recent_ar"
                            return 0
                        fi
                    fi
                    
                    log_info "No active AnalysisRun found"
                    echo ""
                    return 0
                }
                
                # Get and display AnalysisRun details and logs
                show_analysisrun_details() {
                    local ar_name=$1
                    local namespace=$2
                    local ar_json=$3
                    
                    log_info "=== AnalysisRun Details: $ar_name ==="
                    
                    local ar_phase=$(echo "$ar_json" | jq -r '.status.phase // "Unknown"')
                    local ar_message=$(echo "$ar_json" | jq -r '.status.message // "N/A"')
                    local start_time=$(echo "$ar_json" | jq -r '.status.startedAt // "N/A"')
                    
                    log_info "Phase: $ar_phase"
                    log_info "Message: $ar_message"
                    log_info "Started At: $start_time"
                    log_info ""
                    
                    # Show all metrics
                    log_info "Metric Results:"
                    local metric_count=$(echo "$ar_json" | jq '.status.metricResults | length')
                    
                    if [[ "$metric_count" -gt 0 ]]; then
                        echo "$ar_json" | jq -r '.status.metricResults[]? | "
                  Metric: \(.name)
                    Phase: \(.phase)
                    Successful: \(.successful // 0) / \(.count // 0)
                    Failed: \(.failed // 0) / \(.count // 0)
                    Consecutive Errors: \(.consecutiveError // 0)
                    Message: \(.message // "N/A")
                "' >&2
                    else
                        log_info "  No metrics recorded yet"
                    fi
                    
                    log_info ""
                    
                    # Get pod logs for the analysis run
                    log_info "=== AnalysisRun Pod Logs ==="
                    
                    # Extract job names from metric measurements
                    local job_names=$(echo "$ar_json" | jq -r '.status.metricResults[]?.measurements[]?.metadata."job-name" // empty' | sort -u)
                    
                    if [[ -n "$job_names" ]]; then
                        log_info "Found job names from AnalysisRun measurements:"
                        while IFS= read -r job_name; do
                            if [[ -z "$job_name" ]]; then
                                continue
                            fi
                            
                            log_info "Looking for pods from job: $job_name"
                            
                            # Find pods with this job-name label
                            local job_pods=$(kubectl get pods -n "$namespace" -l "job-name=$job_name" -o name 2>/dev/null)
                            
                            if [[ -n "$job_pods" ]]; then
                                while IFS= read -r pod; do
                                    local pod_name=${pod#pod/}
                                    log_info "--- Logs from pod: $pod_name ---"
                                    
                                    # Get logs from the pod
                                    local pod_logs=$(kubectl logs "$pod_name" -n "$namespace" 2>&1)
                                    
                                    if [[ $? -eq 0 ]]; then
                                        # Output logs directly to stderr so they appear in Octopus
                                        echo "$pod_logs" >&2
                                    else
                                        log_warn "Failed to retrieve current logs, trying previous..."
                                        pod_logs=$(kubectl logs "$pod_name" -n "$namespace" --previous 2>&1)
                                        if [[ $? -eq 0 ]]; then
                                            echo "$pod_logs" >&2
                                        else
                                            log_warn "No logs available from $pod_name"
                                        fi
                                    fi
                                    
                                    log_info "--- End logs from $pod_name ---"
                                    log_info ""
                                done <<< "$job_pods"
                            else
                                log_warn "No pods found for job $job_name (may have been cleaned up)"
                            fi
                        done <<< "$job_names"
                    else
                        log_warn "No job metadata found in AnalysisRun measurements"
                        log_info "Falling back to label-based pod search..."
                        
                        # Fallback: Try original label-based searches
                        log_debug "Searching for pods with label analysisRun=$ar_name"
                        local ar_pods=$(kubectl get pods -n "$namespace" -l "analysisRun=$ar_name" -o name 2>/dev/null)
                        
                        if [[ -z "$ar_pods" ]]; then
                            log_debug "Searching by owner reference"
                            ar_pods=$(kubectl get pods -n "$namespace" -o json 2>/dev/null | jq -r --arg ar "$ar_name" '.items[] | select(.metadata.ownerReferences[]?.name == $ar) | "pod/\(.metadata.name)"')
                        fi
                        
                        if [[ -n "$ar_pods" ]]; then
                            while IFS= read -r pod; do
                                local pod_name=${pod#pod/}
                                log_info "--- Logs from pod: $pod_name ---"
                                
                                local pod_logs=$(kubectl logs "$pod_name" -n "$namespace" 2>&1)
                                
                                if [[ $? -eq 0 ]]; then
                                    echo "$pod_logs" >&2
                                else
                                    log_warn "No logs available from $pod_name"
                                fi
                                
                                log_info "--- End logs from $pod_name ---"
                                log_info ""
                            done <<< "$ar_pods"
                        else
                            log_warn "No pods found for AnalysisRun $ar_name"
                            log_info "Pods may have been cleaned up by Kubernetes."
                        fi
                    fi
                    
                    log_info "=== End AnalysisRun Details ==="
                    log_info ""
                }
                
                # Wait for analysis run completion
                wait_for_analysis_completion() {
                    local rollout_name=$1
                    local namespace=$2
                    local start_time=$(date +%s)
                    
                    log_info "Monitoring AnalysisRun completion..."
                    
                    # First check if there's an AnalysisRun at all
                    local ar_name=$(check_analysis_runs "$rollout_name" "$namespace")
                    
                    if [[ -z "$ar_name" ]]; then
                        log_info "No active AnalysisRuns to monitor - completing successfully"
                        return 0
                    fi
                    
                    log_info "Found active AnalysisRun: $ar_name"
                    log_info ""
                    
                    # Now monitor the AnalysisRun until completion
                    while true; do
                        # Get the AnalysisRun details
                        local ar_json
                        ar_json=$(kubectl get analysisrun "$ar_name" -n "$namespace" -o json 2>&1)
                        
                        if [[ $? -ne 0 ]]; then
                            log_warn "Could not retrieve AnalysisRun details, will retry..."
                            sleep $CHECK_INTERVAL
                            continue
                        fi
                        
                        local ar_phase=$(echo "$ar_json" | jq -r '.status.phase // "Unknown"')
                        local ar_message=$(echo "$ar_json" | jq -r '.status.message // "N/A"')
                        
                        case "$ar_phase" in
                            "Successful")
                                log_info "✓ AnalysisRun $ar_name completed successfully"
                                log_info ""
                                
                                # Show details and logs
                                show_analysisrun_details "$ar_name" "$namespace" "$ar_json"
                                
                                return 0
                                ;;
                            "Failed"|"Error")
                                log_error "✗ AnalysisRun $ar_name failed!"
                                log_error ""
                                
                                # Show details and logs
                                show_analysisrun_details "$ar_name" "$namespace" "$ar_json"
                                
                                return 1
                                ;;
                            "Running"|"Pending"|"Inconclusive")
                                log_info "AnalysisRun $ar_name status: $ar_phase - $ar_message"
                                
                                # Show current metric status inline
                                local running_metrics=$(echo "$ar_json" | jq -r '.status.metricResults[]? | "  \(.name): \(.phase) (\(.successful // 0)/\(.count // 0) successful)"')
                                if [[ -n "$running_metrics" ]]; then
                                    echo "$running_metrics" >&2
                                fi
                                ;;
                            *)
                                log_warn "Unknown AnalysisRun phase: $ar_phase"
                                ;;
                        esac
                        
                        local elapsed=$(($(date +%s) - start_time))
                        if [[ $elapsed -gt $MAX_WAIT_TIME ]]; then
                            log_error "Timeout waiting for AnalysisRun completion"
                            log_error ""
                            
                            # Show details and logs even on timeout
                            show_analysisrun_details "$ar_name" "$namespace" "$ar_json"
                            
                            return 1
                        fi
                        
                        sleep $CHECK_INTERVAL
                    done
                }
                
                main() {
                    log_info "=== Argo Rollout Traffic Increment Coordinator ==="
                    log_info "Parameters from Octopus Deploy Process Template:"
                    log_info "  Rollout: $ROLLOUT_NAME"
                    log_info "  Namespace: $NAMESPACE"
                    log_info "  Expected Canary Weight: ${EXPECTED_CANARY_WEIGHT}%"
                    log_info "  Max Wait Time: ${MAX_WAIT_TIME}s"
                    log_info "  Check Interval: ${CHECK_INTERVAL}s"
                    
                    validate_params
                    
                    # Verify kubectl access
                    log_info ""
                    log_info "Verifying kubectl access..."
                    if ! kubectl version --client &> /dev/null; then
                        log_error "kubectl is not available"
                        exit 1
                    fi
                    log_info "✓ kubectl is available"
                    
                    # Step 1: Wait for canary weight to match expected value
                    log_info ""
                    log_info "Step 1: Verifying canary weight update..."
                    if ! wait_for_traffic_update "$EXPECTED_CANARY_WEIGHT"; then
                        log_error "Failed to verify canary weight update"
                        exit 1
                    fi
                    
                    # Step 2: Check rollout health
                    log_info ""
                    log_info "Step 2: Checking rollout health..."
                    if ! check_rollout_health "$ROLLOUT_NAME" "$NAMESPACE"; then
                        log_error "Rollout health check failed"
                        exit 1
                    fi
                    
                    # Step 3: Wait for any analysis runs to complete
                    log_info ""
                    log_info "Step 3: Waiting for analysis tests to complete..."
                    if ! wait_for_analysis_completion "$ROLLOUT_NAME" "$NAMESPACE"; then
                        log_error "Analysis tests failed"
                        exit 1
                    fi
                    
                    log_info ""
                    log_info "=== All checks passed successfully! ==="
                    log_info "Canary increment to ${EXPECTED_CANARY_WEIGHT}% is verified and tests completed"
                }
                
                main
                EOT
            Octopus.Action.Script.ScriptSource = "Inline"
            Octopus.Action.Script.Syntax = "Bash"
            OctopusUseBundledTooling = "False"
        }
        worker_pool_variable = "#{Worker Pool}"
    }
}

step "argo-rollouts-promote-40" {
    name = "Argo - Rollouts Promote (40%)"
    properties = {
        Octopus.Action.TargetRoles = "#{Target Tags}"
    }

    action {
        action_type = "Octopus.KubernetesRunScript"
        properties = {
            Argo.Rollout.FullPromotion = "False"
            Argo.Rollout.Name = "#{RolloutName}"
            Argo.Rollout.Namespace = "#{RolloutNameSpace}"
            Octopus.Action.Script.ScriptBody = <<-EOT
                # Installs the Argo Rollouts plugin
                function Install-Plugin
                {
                # Define parameters
                	param ($PluginUri,
                           $PluginFilename
                    )
                    
                    # Check for plugin folder
                    if ((Test-Path -Path "$PWD/plugins") -eq $false)
                    {
                		# Create new plugins folder
                        New-Item -Path "$PWD/plugins" -ItemType "Directory"
                        
                        # Add to path
                        $env:PATH = "$($PWD)/plugins$([IO.Path]::PathSeparator)" + $env:PATH
                    }
                
                	# Download plugin
                	Invoke-WebRequest -Uri "$PluginUri" -OutFile "$PWD/plugins/$PluginFilename"
                
                	# Make file executable
                    if ($IsLinux)
                    {
                		# Make it executable
                    	chmod +x ./plugins/$PluginFilename
                    }
                    
                    if ($IsWindows)
                    {
                    	# Update filename to include .exe extension
                        Rename-Item -Path "$PWD/plugins/$PluginFilename" -NewName "$PWD/plugins/$($PluginFilename).exe"
                    }
                }
                
                # When listing plugins, kubectl looks in all paths defined in $env:PATH and will fail if the path does not exist
                function Verify-Path-Variable
                {
                	# Get current path and split into array
                    $paths = $env:PATH.Split([IO.Path]::PathSeparator)
                    $verifiedPaths = @()
                    
                    # Loop through paths
                    foreach ($path in $paths)
                    {
                    	# Check for existence
                        if ((Test-Path -Path $path) -eq $true)
                        {
                        	# Add to verified
                            $verifiedPaths += $path
                        }
                    }
                    
                    # Return verified paths
                    return ($verifiedPaths -join [IO.Path]::PathSeparator)
                }
                
                function Get-Plugin-Installed
                {
                	# Define parameters
                    param (
                    	$PluginName,
                        $InstalledPlugins
                        )
                        
                   	$isInstalled = $false
                   
                	foreach ($plugin in $installedPlugins)
                   	{
                		if ($plugin -like "$($PluginName)*")
                        {
                        	$isInstalled = $true
                          	break
                        }
                	}
                    
                    return $isInstalled
                }
                
                # Check to see if $IsWindows is available
                if ($null -eq $IsWindows) {
                    Write-Host "Determining Operating System..."
                    $IsWindows = ([System.Environment]::OSVersion.Platform -eq "Win32NT")
                    $IsLinux = ([System.Environment]::OSVersion.Platform -eq "Unix")
                }
                
                # Fix ANSI Color on PWSH Core issues when displaying objects
                if ($PSEdition -eq "Core") {
                    $PSStyle.OutputRendering = "PlainText"
                }
                
                # Check to see if it's running on Windows
                if ($IsWindows) {
                    # Disable the progress bar so downloading files via Invoke-WebRequest are faster
                    $ProgressPreference = 'SilentlyContinue'
                }
                
                # Set TLS
                [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [System.Net.SecurityProtocolType]::Tls12
                
                # Verify all PATH variables are avaialable
                $env:PATH = Verify-Path-Variable
                if ($IsLinux)
                {
                	$pluginUri = "https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64"
                }
                
                if ($IsWindows)
                {
                	$pluginUri = "https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-windows-amd64"
                }
                
                try 
                {
                    # Check to see if plugins are installed
                    $pluginList = (kubectl plugin list 2>&1)
                
                    # This is the path that Linux will take
                    if ($lastExitCode -ne 0 -and $pluginList.Exception.Message -eq "error: unable to find any kubectl plugins in your PATH") 
                    {
                        Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"
                    }
                    else
                    {
                        # Parse list
                    	$pluginList = $pluginList.Split("`n", [System.StringSplitOptions]::RemoveEmptyEntries)
                        
                        if ((Get-Plugin-Installed -PluginName "kubectl-argo-rollouts" -InstalledPlugins $pluginList) -eq $false)
                        {
                        	Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"
                        }
                        else
                        {
                        	Write-Host "Argo Rollout kubectl plugin found ..."
                        }
                    }    
                }
                catch
                {
                	# On Windows, the executable will cause an error if no plugins found so this the path Windows will take
                    if ($_.Exception.Message -eq "error: unable to find any kubectl plugins in your PATH")
                    {
                		Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"    
                    }
                    else
                    {
                    	# Something else happened, we need to surface the error
                        throw
                    }
                }
                
                # Get parameters
                $rolloutsName = $OctopusParameters['Argo.Rollout.Name']
                $rolloutsNamespace = $OctopusParameters['Argo.Rollout.Namespace']
                $rolloutsFullPromotion = [System.Convert]::ToBoolean($OctopusParameters['Argo.Rollout.FullPromotion'])
                
                # Create arguments array
                $kubectlArguments = @("argo", "rollouts", "promote", $rolloutsName, "--namespace", $rolloutsNamespace)
                
                # Check for additional argument
                if ($rolloutsFullPromotion)
                {
                	$kubectlArguments += "--full"
                }
                
                # Promote rollout
                kubectl $kubectlArguments
                EOT
            Octopus.Action.Script.ScriptSource = "Inline"
            Octopus.Action.Script.Syntax = "PowerShell"
        }
        worker_pool_variable = "#{Worker Pool}"

        community_action_template_snapshot {
            id = "CommunityActionTemplates-30"
            version = 1

            parameter "Argo.Rollout.Name" {
                display_settings = {
                    Octopus.ControlType = "SingleLineText"
                }
                help_text = "Name of the Argo Rollout to promote."
                label = "Rollout Name"
                default_value = ""
            }

            parameter "Argo.Rollout.Namespace" {
                display_settings = {
                    Octopus.ControlType = "SingleLineText"
                }
                help_text = "The namespace to execute the promotion of the rollout against."
                label = "Namespace"
                default_value = "default"
            }

            parameter "Argo.Rollout.FullPromotion" {
                display_settings = {
                    Octopus.ControlType = "Checkbox"
                }
                help_text = "Fully promote a rollout to desired version, skipping analysis, pauses, and steps"
                label = "Full Promotion"
                default_value = "False"
            }
        }
    }
}

step "argo-rollouts-promote-60" {
    name = "Argo - Rollouts Promote (60%)"
    properties = {
        Octopus.Action.TargetRoles = "#{Target Tags}"
    }

    action {
        action_type = "Octopus.KubernetesRunScript"
        properties = {
            Argo.Rollout.FullPromotion = "False"
            Argo.Rollout.Name = "#{RolloutName}"
            Argo.Rollout.Namespace = "#{RolloutNameSpace}"
            Octopus.Action.Script.ScriptBody = <<-EOT
                # Installs the Argo Rollouts plugin
                function Install-Plugin
                {
                # Define parameters
                	param ($PluginUri,
                           $PluginFilename
                    )
                    
                    # Check for plugin folder
                    if ((Test-Path -Path "$PWD/plugins") -eq $false)
                    {
                		# Create new plugins folder
                        New-Item -Path "$PWD/plugins" -ItemType "Directory"
                        
                        # Add to path
                        $env:PATH = "$($PWD)/plugins$([IO.Path]::PathSeparator)" + $env:PATH
                    }
                
                	# Download plugin
                	Invoke-WebRequest -Uri "$PluginUri" -OutFile "$PWD/plugins/$PluginFilename"
                
                	# Make file executable
                    if ($IsLinux)
                    {
                		# Make it executable
                    	chmod +x ./plugins/$PluginFilename
                    }
                    
                    if ($IsWindows)
                    {
                    	# Update filename to include .exe extension
                        Rename-Item -Path "$PWD/plugins/$PluginFilename" -NewName "$PWD/plugins/$($PluginFilename).exe"
                    }
                }
                
                # When listing plugins, kubectl looks in all paths defined in $env:PATH and will fail if the path does not exist
                function Verify-Path-Variable
                {
                	# Get current path and split into array
                    $paths = $env:PATH.Split([IO.Path]::PathSeparator)
                    $verifiedPaths = @()
                    
                    # Loop through paths
                    foreach ($path in $paths)
                    {
                    	# Check for existence
                        if ((Test-Path -Path $path) -eq $true)
                        {
                        	# Add to verified
                            $verifiedPaths += $path
                        }
                    }
                    
                    # Return verified paths
                    return ($verifiedPaths -join [IO.Path]::PathSeparator)
                }
                
                function Get-Plugin-Installed
                {
                	# Define parameters
                    param (
                    	$PluginName,
                        $InstalledPlugins
                        )
                        
                   	$isInstalled = $false
                   
                	foreach ($plugin in $installedPlugins)
                   	{
                		if ($plugin -like "$($PluginName)*")
                        {
                        	$isInstalled = $true
                          	break
                        }
                	}
                    
                    return $isInstalled
                }
                
                # Check to see if $IsWindows is available
                if ($null -eq $IsWindows) {
                    Write-Host "Determining Operating System..."
                    $IsWindows = ([System.Environment]::OSVersion.Platform -eq "Win32NT")
                    $IsLinux = ([System.Environment]::OSVersion.Platform -eq "Unix")
                }
                
                # Fix ANSI Color on PWSH Core issues when displaying objects
                if ($PSEdition -eq "Core") {
                    $PSStyle.OutputRendering = "PlainText"
                }
                
                # Check to see if it's running on Windows
                if ($IsWindows) {
                    # Disable the progress bar so downloading files via Invoke-WebRequest are faster
                    $ProgressPreference = 'SilentlyContinue'
                }
                
                # Set TLS
                [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [System.Net.SecurityProtocolType]::Tls12
                
                # Verify all PATH variables are avaialable
                $env:PATH = Verify-Path-Variable
                if ($IsLinux)
                {
                	$pluginUri = "https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64"
                }
                
                if ($IsWindows)
                {
                	$pluginUri = "https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-windows-amd64"
                }
                
                try 
                {
                    # Check to see if plugins are installed
                    $pluginList = (kubectl plugin list 2>&1)
                
                    # This is the path that Linux will take
                    if ($lastExitCode -ne 0 -and $pluginList.Exception.Message -eq "error: unable to find any kubectl plugins in your PATH") 
                    {
                        Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"
                    }
                    else
                    {
                        # Parse list
                    	$pluginList = $pluginList.Split("`n", [System.StringSplitOptions]::RemoveEmptyEntries)
                        
                        if ((Get-Plugin-Installed -PluginName "kubectl-argo-rollouts" -InstalledPlugins $pluginList) -eq $false)
                        {
                        	Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"
                        }
                        else
                        {
                        	Write-Host "Argo Rollout kubectl plugin found ..."
                        }
                    }    
                }
                catch
                {
                	# On Windows, the executable will cause an error if no plugins found so this the path Windows will take
                    if ($_.Exception.Message -eq "error: unable to find any kubectl plugins in your PATH")
                    {
                		Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"    
                    }
                    else
                    {
                    	# Something else happened, we need to surface the error
                        throw
                    }
                }
                
                # Get parameters
                $rolloutsName = $OctopusParameters['Argo.Rollout.Name']
                $rolloutsNamespace = $OctopusParameters['Argo.Rollout.Namespace']
                $rolloutsFullPromotion = [System.Convert]::ToBoolean($OctopusParameters['Argo.Rollout.FullPromotion'])
                
                # Create arguments array
                $kubectlArguments = @("argo", "rollouts", "promote", $rolloutsName, "--namespace", $rolloutsNamespace)
                
                # Check for additional argument
                if ($rolloutsFullPromotion)
                {
                	$kubectlArguments += "--full"
                }
                
                # Promote rollout
                kubectl $kubectlArguments
                EOT
            Octopus.Action.Script.ScriptSource = "Inline"
            Octopus.Action.Script.Syntax = "PowerShell"
        }
        worker_pool_variable = "#{Worker Pool}"

        community_action_template_snapshot {
            id = "CommunityActionTemplates-30"
            version = 1

            parameter "Argo.Rollout.Name" {
                display_settings = {
                    Octopus.ControlType = "SingleLineText"
                }
                help_text = "Name of the Argo Rollout to promote."
                label = "Rollout Name"
                default_value = ""
            }

            parameter "Argo.Rollout.Namespace" {
                display_settings = {
                    Octopus.ControlType = "SingleLineText"
                }
                help_text = "The namespace to execute the promotion of the rollout against."
                label = "Namespace"
                default_value = "default"
            }

            parameter "Argo.Rollout.FullPromotion" {
                display_settings = {
                    Octopus.ControlType = "Checkbox"
                }
                help_text = "Fully promote a rollout to desired version, skipping analysis, pauses, and steps"
                label = "Full Promotion"
                default_value = "False"
            }
        }
    }
}

step "argo-rollouts-promote-80" {
    name = "Argo - Rollouts Promote (80%)"
    properties = {
        Octopus.Action.TargetRoles = "#{Target Tags}"
    }

    action {
        action_type = "Octopus.KubernetesRunScript"
        properties = {
            Argo.Rollout.FullPromotion = "False"
            Argo.Rollout.Name = "#{RolloutName}"
            Argo.Rollout.Namespace = "#{RolloutNameSpace}"
            Octopus.Action.Script.ScriptBody = <<-EOT
                # Installs the Argo Rollouts plugin
                function Install-Plugin
                {
                # Define parameters
                	param ($PluginUri,
                           $PluginFilename
                    )
                    
                    # Check for plugin folder
                    if ((Test-Path -Path "$PWD/plugins") -eq $false)
                    {
                		# Create new plugins folder
                        New-Item -Path "$PWD/plugins" -ItemType "Directory"
                        
                        # Add to path
                        $env:PATH = "$($PWD)/plugins$([IO.Path]::PathSeparator)" + $env:PATH
                    }
                
                	# Download plugin
                	Invoke-WebRequest -Uri "$PluginUri" -OutFile "$PWD/plugins/$PluginFilename"
                
                	# Make file executable
                    if ($IsLinux)
                    {
                		# Make it executable
                    	chmod +x ./plugins/$PluginFilename
                    }
                    
                    if ($IsWindows)
                    {
                    	# Update filename to include .exe extension
                        Rename-Item -Path "$PWD/plugins/$PluginFilename" -NewName "$PWD/plugins/$($PluginFilename).exe"
                    }
                }
                
                # When listing plugins, kubectl looks in all paths defined in $env:PATH and will fail if the path does not exist
                function Verify-Path-Variable
                {
                	# Get current path and split into array
                    $paths = $env:PATH.Split([IO.Path]::PathSeparator)
                    $verifiedPaths = @()
                    
                    # Loop through paths
                    foreach ($path in $paths)
                    {
                    	# Check for existence
                        if ((Test-Path -Path $path) -eq $true)
                        {
                        	# Add to verified
                            $verifiedPaths += $path
                        }
                    }
                    
                    # Return verified paths
                    return ($verifiedPaths -join [IO.Path]::PathSeparator)
                }
                
                function Get-Plugin-Installed
                {
                	# Define parameters
                    param (
                    	$PluginName,
                        $InstalledPlugins
                        )
                        
                   	$isInstalled = $false
                   
                	foreach ($plugin in $installedPlugins)
                   	{
                		if ($plugin -like "$($PluginName)*")
                        {
                        	$isInstalled = $true
                          	break
                        }
                	}
                    
                    return $isInstalled
                }
                
                # Check to see if $IsWindows is available
                if ($null -eq $IsWindows) {
                    Write-Host "Determining Operating System..."
                    $IsWindows = ([System.Environment]::OSVersion.Platform -eq "Win32NT")
                    $IsLinux = ([System.Environment]::OSVersion.Platform -eq "Unix")
                }
                
                # Fix ANSI Color on PWSH Core issues when displaying objects
                if ($PSEdition -eq "Core") {
                    $PSStyle.OutputRendering = "PlainText"
                }
                
                # Check to see if it's running on Windows
                if ($IsWindows) {
                    # Disable the progress bar so downloading files via Invoke-WebRequest are faster
                    $ProgressPreference = 'SilentlyContinue'
                }
                
                # Set TLS
                [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [System.Net.SecurityProtocolType]::Tls12
                
                # Verify all PATH variables are avaialable
                $env:PATH = Verify-Path-Variable
                if ($IsLinux)
                {
                	$pluginUri = "https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64"
                }
                
                if ($IsWindows)
                {
                	$pluginUri = "https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-windows-amd64"
                }
                
                try 
                {
                    # Check to see if plugins are installed
                    $pluginList = (kubectl plugin list 2>&1)
                
                    # This is the path that Linux will take
                    if ($lastExitCode -ne 0 -and $pluginList.Exception.Message -eq "error: unable to find any kubectl plugins in your PATH") 
                    {
                        Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"
                    }
                    else
                    {
                        # Parse list
                    	$pluginList = $pluginList.Split("`n", [System.StringSplitOptions]::RemoveEmptyEntries)
                        
                        if ((Get-Plugin-Installed -PluginName "kubectl-argo-rollouts" -InstalledPlugins $pluginList) -eq $false)
                        {
                        	Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"
                        }
                        else
                        {
                        	Write-Host "Argo Rollout kubectl plugin found ..."
                        }
                    }    
                }
                catch
                {
                	# On Windows, the executable will cause an error if no plugins found so this the path Windows will take
                    if ($_.Exception.Message -eq "error: unable to find any kubectl plugins in your PATH")
                    {
                		Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"    
                    }
                    else
                    {
                    	# Something else happened, we need to surface the error
                        throw
                    }
                }
                
                # Get parameters
                $rolloutsName = $OctopusParameters['Argo.Rollout.Name']
                $rolloutsNamespace = $OctopusParameters['Argo.Rollout.Namespace']
                $rolloutsFullPromotion = [System.Convert]::ToBoolean($OctopusParameters['Argo.Rollout.FullPromotion'])
                
                # Create arguments array
                $kubectlArguments = @("argo", "rollouts", "promote", $rolloutsName, "--namespace", $rolloutsNamespace)
                
                # Check for additional argument
                if ($rolloutsFullPromotion)
                {
                	$kubectlArguments += "--full"
                }
                
                # Promote rollout
                kubectl $kubectlArguments
                EOT
            Octopus.Action.Script.ScriptSource = "Inline"
            Octopus.Action.Script.Syntax = "PowerShell"
        }
        worker_pool_variable = "#{Worker Pool}"

        community_action_template_snapshot {
            id = "CommunityActionTemplates-30"
            version = 1

            parameter "Argo.Rollout.Name" {
                display_settings = {
                    Octopus.ControlType = "SingleLineText"
                }
                help_text = "Name of the Argo Rollout to promote."
                label = "Rollout Name"
                default_value = ""
            }

            parameter "Argo.Rollout.Namespace" {
                display_settings = {
                    Octopus.ControlType = "SingleLineText"
                }
                help_text = "The namespace to execute the promotion of the rollout against."
                label = "Namespace"
                default_value = "default"
            }

            parameter "Argo.Rollout.FullPromotion" {
                display_settings = {
                    Octopus.ControlType = "Checkbox"
                }
                help_text = "Fully promote a rollout to desired version, skipping analysis, pauses, and steps"
                label = "Full Promotion"
                default_value = "False"
            }
        }
    }
}

step "increase-traffic-to-100" {
    name = "Increase Traffic to 100%"

    action {
        action_type = "Octopus.Manual"
        properties = {
            Octopus.Action.Manual.BlockConcurrentDeployments = "False"
            Octopus.Action.Manual.Instructions = "Increases Traffic to 100%"
            Octopus.Action.Manual.ResponsibleTeamIds = "global/octopus-managers"
        }
    }
}

step "argo-rollouts-promote-100" {
    name = "Argo - Rollouts Promote (100%)"
    properties = {
        Octopus.Action.TargetRoles = "#{Target Tags}"
    }

    action {
        action_type = "Octopus.KubernetesRunScript"
        properties = {
            Argo.Rollout.FullPromotion = "False"
            Argo.Rollout.Name = "#{RolloutName}"
            Argo.Rollout.Namespace = "#{RolloutNameSpace}"
            Octopus.Action.Script.ScriptBody = <<-EOT
                # Installs the Argo Rollouts plugin
                function Install-Plugin
                {
                # Define parameters
                	param ($PluginUri,
                           $PluginFilename
                    )
                    
                    # Check for plugin folder
                    if ((Test-Path -Path "$PWD/plugins") -eq $false)
                    {
                		# Create new plugins folder
                        New-Item -Path "$PWD/plugins" -ItemType "Directory"
                        
                        # Add to path
                        $env:PATH = "$($PWD)/plugins$([IO.Path]::PathSeparator)" + $env:PATH
                    }
                
                	# Download plugin
                	Invoke-WebRequest -Uri "$PluginUri" -OutFile "$PWD/plugins/$PluginFilename"
                
                	# Make file executable
                    if ($IsLinux)
                    {
                		# Make it executable
                    	chmod +x ./plugins/$PluginFilename
                    }
                    
                    if ($IsWindows)
                    {
                    	# Update filename to include .exe extension
                        Rename-Item -Path "$PWD/plugins/$PluginFilename" -NewName "$PWD/plugins/$($PluginFilename).exe"
                    }
                }
                
                # When listing plugins, kubectl looks in all paths defined in $env:PATH and will fail if the path does not exist
                function Verify-Path-Variable
                {
                	# Get current path and split into array
                    $paths = $env:PATH.Split([IO.Path]::PathSeparator)
                    $verifiedPaths = @()
                    
                    # Loop through paths
                    foreach ($path in $paths)
                    {
                    	# Check for existence
                        if ((Test-Path -Path $path) -eq $true)
                        {
                        	# Add to verified
                            $verifiedPaths += $path
                        }
                    }
                    
                    # Return verified paths
                    return ($verifiedPaths -join [IO.Path]::PathSeparator)
                }
                
                function Get-Plugin-Installed
                {
                	# Define parameters
                    param (
                    	$PluginName,
                        $InstalledPlugins
                        )
                        
                   	$isInstalled = $false
                   
                	foreach ($plugin in $installedPlugins)
                   	{
                		if ($plugin -like "$($PluginName)*")
                        {
                        	$isInstalled = $true
                          	break
                        }
                	}
                    
                    return $isInstalled
                }
                
                # Check to see if $IsWindows is available
                if ($null -eq $IsWindows) {
                    Write-Host "Determining Operating System..."
                    $IsWindows = ([System.Environment]::OSVersion.Platform -eq "Win32NT")
                    $IsLinux = ([System.Environment]::OSVersion.Platform -eq "Unix")
                }
                
                # Fix ANSI Color on PWSH Core issues when displaying objects
                if ($PSEdition -eq "Core") {
                    $PSStyle.OutputRendering = "PlainText"
                }
                
                # Check to see if it's running on Windows
                if ($IsWindows) {
                    # Disable the progress bar so downloading files via Invoke-WebRequest are faster
                    $ProgressPreference = 'SilentlyContinue'
                }
                
                # Set TLS
                [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls11 -bor [System.Net.SecurityProtocolType]::Tls12
                
                # Verify all PATH variables are avaialable
                $env:PATH = Verify-Path-Variable
                if ($IsLinux)
                {
                	$pluginUri = "https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-linux-amd64"
                }
                
                if ($IsWindows)
                {
                	$pluginUri = "https://github.com/argoproj/argo-rollouts/releases/latest/download/kubectl-argo-rollouts-windows-amd64"
                }
                
                try 
                {
                    # Check to see if plugins are installed
                    $pluginList = (kubectl plugin list 2>&1)
                
                    # This is the path that Linux will take
                    if ($lastExitCode -ne 0 -and $pluginList.Exception.Message -eq "error: unable to find any kubectl plugins in your PATH") 
                    {
                        Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"
                    }
                    else
                    {
                        # Parse list
                    	$pluginList = $pluginList.Split("`n", [System.StringSplitOptions]::RemoveEmptyEntries)
                        
                        if ((Get-Plugin-Installed -PluginName "kubectl-argo-rollouts" -InstalledPlugins $pluginList) -eq $false)
                        {
                        	Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"
                        }
                        else
                        {
                        	Write-Host "Argo Rollout kubectl plugin found ..."
                        }
                    }    
                }
                catch
                {
                	# On Windows, the executable will cause an error if no plugins found so this the path Windows will take
                    if ($_.Exception.Message -eq "error: unable to find any kubectl plugins in your PATH")
                    {
                		Install-Plugin -PluginUri $pluginUri -PluginFilename "kubectl-argo-rollouts"    
                    }
                    else
                    {
                    	# Something else happened, we need to surface the error
                        throw
                    }
                }
                
                # Get parameters
                $rolloutsName = $OctopusParameters['Argo.Rollout.Name']
                $rolloutsNamespace = $OctopusParameters['Argo.Rollout.Namespace']
                $rolloutsFullPromotion = [System.Convert]::ToBoolean($OctopusParameters['Argo.Rollout.FullPromotion'])
                
                # Create arguments array
                $kubectlArguments = @("argo", "rollouts", "promote", $rolloutsName, "--namespace", $rolloutsNamespace)
                
                # Check for additional argument
                if ($rolloutsFullPromotion)
                {
                	$kubectlArguments += "--full"
                }
                
                # Promote rollout
                kubectl $kubectlArguments
                EOT
            Octopus.Action.Script.ScriptSource = "Inline"
            Octopus.Action.Script.Syntax = "PowerShell"
        }
        worker_pool_variable = "#{Worker Pool}"

        community_action_template_snapshot {
            id = "CommunityActionTemplates-30"
            version = 1

            parameter "Argo.Rollout.Name" {
                display_settings = {
                    Octopus.ControlType = "SingleLineText"
                }
                help_text = "Name of the Argo Rollout to promote."
                label = "Rollout Name"
                default_value = ""
            }

            parameter "Argo.Rollout.Namespace" {
                display_settings = {
                    Octopus.ControlType = "SingleLineText"
                }
                help_text = "The namespace to execute the promotion of the rollout against."
                label = "Namespace"
                default_value = "default"
            }

            parameter "Argo.Rollout.FullPromotion" {
                display_settings = {
                    Octopus.ControlType = "Checkbox"
                }
                help_text = "Fully promote a rollout to desired version, skipping analysis, pauses, and steps"
                label = "Full Promotion"
                default_value = "False"
            }
        }
    }
}